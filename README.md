## 事务
### 事务的四大特性ACID
事务是逻辑上的一组操作，要么都执行，要么都不执行。
+ 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
+ 一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
+ 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
+ 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
### 并发事务会造成的问题
+ 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
+ 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
+ 不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

## MySQL的并发控制
### 读写锁
在处理并发读或者写的时候，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常称为共享锁和排他锁，也叫读锁和写锁
+ 读锁是共享的，或者说是相互不阻塞的。多个客户可以同时读取同一个资源，而互不干扰
+ 死锁是排他的。也就是说一个死锁会阻塞其他的写锁和读锁，保证在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的统一资源。
### 锁粒度
一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高。
问题是加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否解除、释放锁等，都会增加系统的开销。
所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。
两种重要的锁策略：
+ 表锁：MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表，一个用户在对表进行写操作前，需要先获取写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁的时候，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。
+ 行级锁：行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。

## 主从复制
### 什么是MySQL的主从复制
主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。MySQL主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。
### 主从复制的类型
+ 基于语句的复制：主服务器上面执行的语句在从服务器上面再执行一遍；存在的问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户。
+ 基于行的复制：把主服务器上面改编后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的；存在的问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。
+ 混合类型的复制：MySQL默认使用基于语句的复制，当基于语句的复制会引发问题的时候就会使用基于行的复制，MySQL会自动进行选择；在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行。主从复制架构虽然给读操作提供了扩展，可如果写操作也比较多的话（多台从服务器还要从主服务器上面同步数据），单主模型的复制中主服务器势必会成为性能瓶颈。
### 工作原理
主从复制主要涉及三个线程：binlog线程，IO线程，SQL线程
+ binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
+ I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
+ SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。
## 读写分离
### 什么是读写分离
让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。

# InnoDB深入学习
InnoDB有四种行格式：Compact、Redundant、Dynamic和Compressed
行格式是在创建或者修改表的时候指定的
```SQL
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55FVTOrSL5huibzeawNtia5ey37MIoP0YPpYdY7Y0TO0iaZ3a79QB7GiaHyTqJTicNBQ6Nk202h4JECicib3A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 
从图中可以看出来，一条完整的记录其实可以被分为**记录的额外信息**和**记录的真实数据**两大部分
### 记录的额外信息
#### 变长字段长度列表
如VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型，这些变长的数据类型占用的存储空间分为两部分：
+ 真正的数据内容
+ 占用的字节数
因为如果不保存真实数据占用的字节数的话，MySQL也不知道我们的数据到底有多长。在Compact行格式中，**把所有变长类型的列的长度都存放在记录的开头部位形成一个列表，按照列的顺序逆序存放**
#### NULL值列表 
表中的某些列可能会存储NULL值，如果把这些NULL值都放在记录的真实数据中存储会很占地方，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中。
1. 首先统计表中允许存储NULL值的列有哪些
2. 如果表中没有允许存储NULL的列，则NULL值列表也不存在了。否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：
    + 二进制位的值为1时，代表该列的值为NULL。
    + 二进制位的值为0时，代表该列的值为NULL。
3. MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。

#### 记录头信息
由固定的5个字节组成，5个字节就是40个bit，不同的位代表不同的信息
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55FVTOrSL5huibzeawNtia5ey3seeEXfe32gnNpyFDpGADNaia0ytgBf2l35mLFECb1jI4HJmEoFJAOmA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

|名称|大小(bit)|描述|
|---|---|--|
|预留位1|1|没有使用|
|预留位2|1|没有使用|
|delete_mask|1|标记该记录是否被删除|
|min_rec_mask|1|标记该记录是否为B+树的非叶子节点中的最小记录|
|n_owned|4|表示当前槽管理的记录数|
|heap_no|13|表示当前记录在记录堆的位置信息|
|record type|3|	表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录|
|next_record|16|表示下一条记录的相对位置|

## 记录的真实数据
记录的真实数据除了我们插入的那些列的数据，MySQL会为每个记录默认的添加一些列（也称为隐藏列）：
|列名|是否必须|占用空间|描述|
|--|--|--|--|
|row_id|否|6byte|行id，唯一标识一条记录|
|transaction_id|是|6byte|事务id|
|roll_pointer|是|7byte|回滚指针|
需要注意的是，MySQL服务器会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 只有在表没有定义主键的时候才会为记录添加，相当于MySQL服务器帮我们来添加一个主键。
# InnoDB数据页结构
页是MySQL管理存储空间的基本单位，一个页的大小一般是16KB，并且我们知道了记录其实是被存放在页中的，如果记录占用的空间太大还可能造成行溢出现象，这会导致一条记录被分散存储在多个页中。
## 数据页结构
页的本质就是一块16KB大小的存储空间，InnoDB为了不同目的而把页分为不同的类型，其中用于存放记录的页也称为数据页
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55FusCptW3JwBoBchTsR6PJ5YoHfS02chsR4bSERrblH0ousvlric9BV3QcGrCClQ7qibWVWWhx5hQaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
从图中可以看出，一个InnoDB分为七个部分，每个部分又可以划分为若干小部分
|名称|中文名|占用空间大小|简单描述|
|----|------|------------|--------|
|File Header|文件头|38byte|一些描述页的信息|
|Page Header|页头|56byte|页的状态信息|
|Infimum+supremum|最小记录+最大记录|26byte|两个虚拟的行记录|
|User Records|用户记录|不确定|实际存储的行记录内容|
|Free Space|空闲空间|不确定|页中尚未使用的空间|
|Page Directory|页目录|不确定|页中的记录相对位置|
|File Tailer|文件结尾|8byte|校验页是否完整|
## 记录在页中的存储
在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55FusCptW3JwBoBchTsR6PJ5xibbpE0yjbGYUwszT98icQbzOJibia0aufvOZV4FR6xfJ1HF0jBnmr8fGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
先建一个测试表
```SQL
CREATE TABLE page_demo(
c1 INT,
c2 INT,
c3 VARCHAR(10000),
PRIMARY KEY (c1)
) CHARSET=ascii ROW_FORMAT=Compact;
```
这个测试表page_demo有三列，其中c1和c2存储整数，c3用来存储字符串。需要注意的是，我们把 c1 列指定为主键，所以在具体的行格式中MySQL就没必要为我们去创建那个所谓的 row_id 隐藏列了。而且我们为这个表指定了ascii字符集以及Compact的行格式。
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55FusCptW3JwBoBchTsR6PJ5hYfxQdBqg3YHWSiaxNOeVgO9AjFf2RB8nFibCuU2qtpwiah1hic48YLqMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
插入数据
```SQL
INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
```
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55FusCptW3JwBoBchTsR6PJ5oWkKqKo9H1FGZQHIr1Hv7mqP2MMeAnzctpxhAdmQaMS2sONwoKZKrQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
通过对照此图分析记录头信息
+ delete_mask
    记录被删除的时候为1，没删除的时候为0。
    为什么会出现这种情况呢？难道删除以后记录还驻留在磁盘中吗？
    这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打个删除标记而已，而且这部分存储空间之后还可以重用，也就是说之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
+ min_rec_mask
    这个属性标记该记录是否为B+树的非叶子节点中的最小记录，我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。
+ n_owned
+ heap_no
    这个属性表示当前记录在本页中的位置，从图中可看出，插入的四条数据分别在2,3,4,5的位置。那为什么没有0和1呢？其实是InnoDB自动给每个页加了两个记录。由于这两个记录并不是我们加上的，所以又称为伪记录或者虚拟记录。这两个记录一个代表最小记录，一个代表最大纪录
+ 最小记录和最大纪录
    ![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55FusCptW3JwBoBchTsR6PJ5q6u2DgI6upKIyTX3EFgc3z2icHNicVp2ibqwmob8Rf7nnYbvmuqH3Q8MA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
    由于这两条记录并不是我们自己插入的记录，所以它们并不在UserRecord里面，它们被单独放在Infimum+Supremum的部分
+ record_type
    这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的record_type值都是0，而最小记录和最大记录的record_type值分别为2和3。
+ next_record
    表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的next_record值为36，意味着从第一条记录的真实数据的地址处向后找36个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 最小记录 的下一条记录就本页中主键值最小的记录，而本页中主键值最大的记录的下一条记录就是 最大记录。
## 页目录
```SQL
select * from page_demo where c1 = 3;
```
根据主键值查找某条记录应该怎么查找？
最笨的方法：从头到尾遍历一遍，从最小记录开始，沿着链表一直往后找。
InnoDB的方法：
1. 将所有正常的记录（包括最大最小记录，不包括已标记为删除的记录）划分为几个组
2. 每个组的最后一条记录的头信息中的n_owned属性表示该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个槽（英文名：Slot）。这些地址偏移量都会被存储到靠近页的尾部的地方，页中存储地址偏移量的部分也被称为Page Directory（可以看前边数据页的组成示意图）。
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55FusCptW3JwBoBchTsR6PJ5s8gVLQEAmgs9ust3JKibbKwnlL3lhuialNayaHFSZcXuOaTZcDorDouA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
图中共有六条记录，InnoDB将他们分为两组，第一组只有一个最小记录，其他5个记录在第二组
从图中需要注意：
+ 现在Page Directory部分中有两个槽，也就意味着我们的记录被分成了两个组，槽0中的值是112，代表最大记录的地址偏移量；槽1中的值是99，代表最小记录的地址偏移量。
+ 最小和最大记录的头信息中的n_owned属性
    - 最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身
    - 最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。
## 关于分组
#### 分组规定
对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。
#### 分组过程
1. 初始情况下一个数据页只有最小记录和最大纪录两条记录，他们分属于两个分组
2. 之后每插入一跳记录都把这条记录放到最大记录所在的组，直到最大记录所在组中的记录数等于8个
3. 在最大记录所在组中的记录数等于8个的时候再插入一条记录时，将最大记录所在组平均分裂成2个组，然后最大记录所在的组就剩下4条记录了，然后就可以把即将插入的那条记录放到该组中了
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55FusCptW3JwBoBchTsR6PJ5QicCquOS6FndV5ISAgfTkjD4AuaayCXsia2cZOIdjtF50ZuFQpGKjaAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
#### 如何从页目录中查找记录？
因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。4个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为5的记录，过程是这样的：
1. 计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 > 5，所以设置high=2，low保持不变。
2. 重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4。所以设置low=1，high保持不变。
3. 因为high - low的值为1，所以确定主键值为5的记录在槽1和槽2之间，接下来就是遍历链表的查找了。
所以在一个数据页中查找主键值的记录的过程分为两步
+ 通过二分法确定所在的槽
+ 通过记录的next_record属性组成的链表遍历查找该槽中的各个记录
## File Trailer
InnoDB存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以页为单位把数据加载到内存中处理，如果该页中的数据在内存被修改了，那么在修改以后的某个时间需要把数据同步到磁盘中。但难免会出现同步过程中发生意外的情况。所以InnoDB在每个页的尾部都加了一个File Trailer部分，这个部分由8个字节组成，可分为两个部分：
+ 前四个字节代表页的校验和
    这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的，反之意味着同步中间出了错。
+ 后四个字节代表日志序列位置(LSN)
    这个部分也是为了校验页的完整性的
# 索引部分
## 没有索引时，如何查找记录
### 在一个页中查找
根据搜索条件的不同，分为两种情况：
+ 以主键为搜索条件
可以再页目录中通过二分快速定位到对应的槽，然后再遍历该槽对应分组的记录
+ 以其他列为搜索条件
因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。
### 在很多页中查找
大部分情况下我们存储的数据都是非常多的，需要很多的数据页来存储。所以分为两个步骤
1. 定位到记录所在的页
2. 从所在的页中查找相应的记录
不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上边已经唠叨过的查找方式去查找指定的记录。效率很低
## 设计一个简单的索引方案
在没有索引的时候，我们往往要遍历所有的记录，为什么要这样呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？就像为数据页中的记录建立一个目录一样，我们也可以为所有的数据页建立一个目录呀，建这个目录必须完成下边这些事儿：
+ 下一个数据页的主键值必须大于上一个数据页中的主键值
	其实这句话的完整表述是这样的：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值
	我们先假设有这么一个数据页，每一个数据页最多存放3条记录，往里面插入3条记录
	![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5q6J8GPUT3q4UqnrAsSnq06z9TCSu84zbAgy0Od5iaeFYxnYgq7UPcxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
	按照主键值排好序以后，串联成一个单链表，从图中可以看出，这3条记录都插入到了编号为10的数据页中。
	此时我们再插入一条(4,4,'a')的数据
	因为页10只能放下3条记录，我们不得不多分配一个页存储新插入的数据
	![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5vXnXaVRLuFfvTP6nFqfJcsW3EaL1fXReB2IicVdwdhU7ZFJArvbtsNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
	分配的页号是28不是11的原因：新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系。另外，页10中用户记录最大的主键值是5，而页28中有一条记录的主键值是4，因为5 > 4，所以这就不符合下一个数据页的主键值必须大于上一个页中的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次记录移动，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：
	![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5j0XMAFhNFGsbgJIWDNYE2Aypw2E7RVXOt0kfkUB6IdeGEwhmxdU8Jw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
+ 给所有的页建立一个目录项
	由于数据页的编号可能并不是连续的，所以在向index_demo表中插入许多条记录后，可能是这样的效果：
	![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5ZGO727B5iasz8PrAtNRIUKNBo0Tu1T4ic8RibSLibXyja76IVagRbUgPvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
	因为这些16KB的页在物理存储上并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：
	- 页的用户记录中最小的主键值，我们用key来表示。
	- 页号，我们用page_no表示。
所以在最后，整个页的结构变成了这样：
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5ozFlSTtNFzChYKrpiazTDbPthEicczaTeaQr3fastzoxC8KlaZCibs1qw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
以页28为例，它对应目录项2，这个目录项中包含着该页的页号28以及该页中用户记录的最小主键值5。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为20的记录，具体查找过程分两步：
1. 先从目录项中根据二分法快速确定出主键值为20的记录在目录项3中（因为 12 < 20 < 209），它对应的页是页9。
2. 再根据前边说的在页中查找记录的方式去页9中定位具体的记录。
至此，针对数据页做的简易目录就搞定了。不过忘了说了，这个目录有一个别名，称为**索引**。
## InnoDB的索引方案
上边的方案之所以称为简易的索引方案，是因为我们假设所有目录项都可以在物理存储器上连续存储。这样做有几个问题：
1. InnoDB是使用页来作为管理存储空间的基本单位，也就是最多能保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。
2. 我们时常会对记录进行增删，假设我们把页28中的记录都删除了，页28也就没有存在的必要了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意～
InnoDB的设计者想到了一种能灵活管理所有目录项的方式，他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那InnoDB如何区分一条记录是普通的用户记录还是目录项记录呢？根据记录头信息的record_type属性。
+ 0：普通的用户记录
+ 1：目录项记录
+ 2：最小记录
+ 3：最大记录
所以，最后将目录项放到数据页是这个样子的：
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5NZqsib5J1jNO4abfJkqx5DHK6L9HxOCV685DoOZibLtc0vvIUHJUCKaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
从图中可以看出，我们新分配了一个编号为30的页来专门存储目录项记录。目录项记录和普通的用户记录的不同点：
+ 目录项记录的record_type的值是1，而普通用户记录的record_type的值是0
+ 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列
+ 头信息中有一个叫min_rec_mask的属性，只有在存储目录项记录的页的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值为0.
以查找主键为20为例子：
1. 先到存储目录项记录的页中通过二分法快速定位到对应目录项，因为12 < 20 < 209，所以定位到对应的记录所在的页就是页9.
2. 从页9中根据二分法快速定位到主键值为20的用户记录。
如果表中数据太多，以至于一个数据页不足以存放所有的目录项记录该怎么办？
再多设置一个存储**目录项记录**的页。我们假设一个存储目录项记录的数据页最多只能放4条记录，如果我们再向上图插入一条主键为320的记录，那就需要再多加一页
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5ziagxVtrria1wFssO2kDh8QGVY7RMP2gQVv8Hrl7lZRYaiaib6iaq6ibbYyA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
从图中可看出，插入主键值为320的数据以后新生成了两个数据页，以查找主键值为20的记录为例：
1. 确定目录项记录所在的页
    我们现在的存储**目录项记录**的页有两个，即页30和页32，又因为页30表示的目录项的主键值范围是[1,320)，页32表示的目录项的主键值不小于320，所以主键值为20的记录对应的目录项记录在页30
2. 通过目录项记录页确定用户记录真实所在的页
    在一个存储目录项记录中定位一条目录项记录的方式说过了，不赘述了～
3. 在真实存储用户记录的页中定位到具体的记录
    在一个存储用户记录的页中定位一条真实的用户记录的方式已经说过200遍了，你再不会我就，我就，我就求你到上一篇唠叨数据页结构的文章中多看几遍，求你了～
这样查找也有问题，我们需要定位存储**目录项记录**的页，但这些页在存储空间可能不是连续的，如果表的数据很多则会产生很多存储目录项记录的页，那么如何根据主键值快速定位一个存储目录项记录的页呢？
为这些存储目录项记录的页再生成一个更高级的目录。所以现在各个页的示意图：
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt55ga3Fmqa9Hicn9CQ6Lh2ibT7chylHXd6C6RdrbmZdmFzZJiafyoyjyIjQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
如图，我们生成了一个存储更高级目录项的页33，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在[1, 320)之间，则到页30中查找更详细的目录项记录，如果主键值不小于320的话，就到页32中查找更详细的目录项记录。不过这张图好漂亮喔，随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：
![](https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt56qjeJSb5FCRicOUQP41w9dT0L67wYQeLu8jfxkeszZI45Tx9Eaibad7w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
这就变成了一棵树，在InnoDB中，使用的是树里面的B+树
从图中可以看出，我们的实际用户记录都放在了B+树的最底层的节点上，这些节点称为叶子节点，其余节点都是用来存放目录项的，这些节点称为内节点。

## 索引概念
MySQL官方对于索引的定义：索引是帮助MySQL高效获取数据的数据结构
索引类型：
+ 普通索引：加速查询
+ 唯一索引：加速查询 + 列值唯一（可以有null）
+ 主键索引：加速查询 + 列值唯一（不可以有null） + 表中只有一个
+ 组合索引：多列值组成一个索引，专门用于组合搜索，其效率>索引合并
+ 全文索引：对文本的内容分词，进行搜索
在文件系统及数据库系统中，多采用B+Tree作为索引结构。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。
为何使用B+Tree而不是红黑树？
1. 更少的查询次数
平衡树的查找操作的时间复杂度和树的高度h相关，O(h)=O(logdN)，其中d为每个节点的出度。红黑树的出度为2，而B+Tree的出度一般都非常大，所以红黑树的树高h很明显比B+Tree大很多，查找的次数也就更多
2. 利用磁盘预读特性
为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会特别快。操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次IO就能完全载入一个节点，并且利用预读特性，相邻的结点也能够被预先载入。
## MySQL的索引实现
### InnoDB索引实现
InnoDB同样使用B+Tree作为索引结构，但是具体方式与MyISAM截然不同，区别在于：
1. InnoDB的数据文件本身就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅仅保存数据记录的地方。而在InnoDB中，表数据文件本身就是按照B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引
